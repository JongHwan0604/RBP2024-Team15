import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
from std_msgs.msg import Header
import numpy as np
import cv2

class DetermineColor(Node):
    def __init__(self):
        super().__init__('color_detector')
        self.image_sub = self.create_subscription(Image, '/color', self.callback, 10)
        self.color_pub = self.create_publisher(Header, '/rotate_cmd', 10)
        self.bridge = CvBridge()

    def callback(self, data):
        try:
            # listen image topic
            image = self.bridge.imgmsg_to_cv2(data, 'bgr8')

            # prepare rotate_cmd msg
            # DO NOT DELETE THE BELOW THREE LINES!
            msg = Header()
            msg = data.header
            msg.frame_id = '0'  # default: STOP

            # determine background color
            result = self.determine_color(image)
            if result == 'R':
                msg.frame_id = '+1'  # CCW
            elif result == 'G':
                msg.frame_id = '0'  # STOP
            elif result == 'B':
                msg.frame_id = '-1'  # CW

            # publish color_state
            self.color_pub.publish(msg)
        except CvBridgeError as e:
            self.get_logger().error('Failed to convert image: %s' % e)

    def determine_color(self, image):
        img_hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        mask_black = cv2.inRange(img_hsv, np.array([0, 0, 0]), np.array([180, 255, 50]))
        contours, _ = cv2.findContours(mask_black, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        def filter_contours(contours):
            filtered_contours = []
            for contour in contours:
                if cv2.contourArea(contour) > 2000:
                    enf = cv2.arcLength(contour, True)
                    rms = cv2.approxPolyDP(contour, 0.02 * enf, True)
                    if len(rms) == 4:
                        filtered_contours.append(contour)
            return filtered_contours

        valid_contours = filter_contours(contours)

        if not valid_contours:
            return None

        color_count = {'R': 0, 'G': 0, 'B': 0}
        for contour in valid_contours:
            mask = np.zeros(img_hsv.shape[:2], dtype=np.uint8)
            cv2.drawContours(mask, [contour], -1, 255, -1)
            masked_img = cv2.bitwise_and(img_hsv, img_hsv, mask=mask)

            rm = cv2.inRange(masked_img, (0, 50, 50), (10, 255, 255)) | cv2.inRange(masked_img, (170, 50, 50), (180, 255, 255))
            gm = cv2.inRange(masked_img, (50, 50, 50), (70, 255, 255))
            bm = cv2.inRange(masked_img, (110, 50, 50), (130, 255, 255))

            color_count['R'] += cv2.countNonZero(rm)
            color_count['G'] += cv2.countNonZero(gm)
            color_count['B'] += cv2.countNonZero(bm)

        dominant_color = max(color_count, key=color_count.get)
        return dominant_color

def main(args=None):
    rclpy.init(args=args)
    detector = DetermineColor()
    rclpy.spin(detector)
    detector.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
