import rclpy
import numpy as np
import cv2
from glob import glob
from rclpy.node import Node

from sensor_msgs.msg import Image, CompressedImage
from cv_bridge import CvBridge, CvBridgeError
from std_msgs.msg import Header

class DetermineColor(Node):
    def __init__(self):
        super().__init__('color_detector')
        self.image_sub = self.create_subscription(Image, '/color', self.callback, 10)
        self.color_pub = self.create_publisher(Header, '/rotate_cmd', 10)
        self.bridge = CvBridge()

    def callback(self, data):
        try:
            # 이미지 주제 수신
            image = self.bridge.imgmsg_to_cv2(data, 'bgr8')

            # rotate_cmd 메시지 준비
            msg = Header()
            msg = data.header
            msg.frame_id = '0'  # 기본값: 정지

            # 배경 색상 결정
            # TODO: 색상을 결정하고 frame_id에 +1, 0, 또는 -1 할당
            # msg.frame_id = '+1' # 반시계 방향
            # msg.frame_id = '0'  # 정지
            # msg.frame_id = '-1' # 시계 방향

            # publish color_state
            self.color_pub.publish(msg)
        except CvBridgeError as e:
            self.get_logger().error('Failed to convert image: %s' % e)

def determine_color_from_file(filename):
    img_0 = cv2.imread(filename)    
    
    if img_0 is None:
        return None

    img_1 = cv2.cvtColor(img_0, cv2.COLOR_BGR2HSV)

    B = cv2.inRange(img_1, np.array([0,0,0]), np.array([180,255,50]))
    C, _ = cv2.findContours(B, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    mps = filter_contours(C)
        
    if not mps:
        return None

    CR = {'R': 0, 'G': 0, 'B': 0}
    for mp in mps:
        mask = np.zeros(img_1.shape[:2], dtype = np.uint8)
        cv2.drawContours(mask, [mp], -1, 255, -1)
        mrh = cv2.bitwise_and(img_1, img_1, mask=mask)
        
        rm = cv2.inRange(mrh, (0, 50, 50), (10, 255, 255)) | cv2.inRange(mrh, (170, 50, 50), (180, 255, 255))
        gm = cv2.inRange(mrh, (50, 50, 50), (70, 255, 255))
        bm = cv2.inRange(mrh, (110, 50, 50), (130, 255, 255))
        
        CR['R'] += cv2.countNonZero(rm)
        CR['G'] += cv2.countNonZero(gm)
        CR['B'] += cv2.countNonZero(bm)
        
    DC = max(CR, key=CR.get)
    return DC

def filter_contours(contours):
    max_contour = None
    max_area = -1
    for contour in contours:
        area = cv2.contourArea(contour)
        if area > max_area:
            enf = cv2.arcLength(contour, True)
            rms = cv2.approxPolyDP(contour, 0.02*enf, True)
            if len(rms) == 4:  # Assuming it's a rectangle
                max_contour = contour
                max_area = area
    if max_contour is not None:
        return [max_contour]  # Return only the contour with the largest area
    else:
        return []

if __name__ == '__main__':
    rclpy.init()
    try:
        detector = DetermineColor()
        rclpy.spin(detector)
    finally:
        detector.destroy_node()
        rclpy.shutdown()

    # 파일로부터 색상 결정 부분은 별도의 실행 코드로 필요 시 사용
    # result = []
    # for filename in sorted(glob('public_imgs/*.PNG')):
    #     DC = determine_color_from_file(filename)
    #     result.append(DC)
    # print(result)

