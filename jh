import rclpy
import numpy as np
import cv2
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
from std_msgs.msg import Header

class DetermineColor(Node):
    def __init__(self):
        super().__init__('color_detector')
        self.image_sub = self.create_subscription(Image, '/camera/color/image_raw', self.callback, 10)
        self.color_pub = self.create_publisher(Header, '/rotate_cmd', 10)
        self.bridge = CvBridge()
        self.tracker = cv2.TrackerCSRT_create()  # CSRT 트래커 생성
        self.initBB = None  # 트래킹할 객체의 초기 바운딩 박스
        self.frame_count = 0
        self.Rtotals = []
        self.Gtotals = []
        self.Btotals = []

    def callback(self, data):
        try:
            # 이미지 토픽 수신
            image = self.bridge.imgmsg_to_cv2(data, 'bgr8')

            # 이미지 전처리
            image = cv2.GaussianBlur(image, (5, 5), 0)  # 노이즈 제거
            image_lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)  # LAB 색상 공간으로 변환

            # 회전 명령 메시지 준비
            msg = Header()
            msg.stamp = data.header.stamp
            msg.frame_id = '0'  # 기본값: STOP

            # 초기 바운딩 박스 설정
            if self.initBB is None:
                self.initBB = cv2.selectROI("Frame", image, fromCenter=False, showCrosshair=True)
                self.tracker.init(image, self.initBB)
                cv2.destroyWindow("Frame")

            # 트래킹 업데이트
            (success, box) = self.tracker.update(image)

            if success:
                (x, y, w, h) = [int(v) for v in box]
                cv2.rectangle(image, (x, y), (x + w, y + h), (0, 255, 0), 2)

                # 트래킹한 영역 내에서 색상 분석
                roi = image[y:y+h, x:x+w]
                roi_lab = image_lab[y:y+h, x:x+w]

                # 조명 조건 보정
                roi_lab[:, :, 0] = cv2.equalizeHist(roi_lab[:, :, 0])
                roi = cv2.cvtColor(roi_lab, cv2.COLOR_LAB2BGR)

                # RGB 색상 분석
                Rtotal = np.sum((roi[:, :, 2] > 100) & (roi[:, :, 1] < 80) & (roi[:, :, 0] < 80))
                Gtotal = np.sum((roi[:, :, 1] > 100) & (roi[:, :, 2] < 80) & (roi[:, :, 0] < 80))
                Btotal = np.sum((roi[:, :, 0] > 100) & (roi[:, :, 1] < 80) & (roi[:, :, 2] < 80))

                # 결과 누적
                self.Rtotals.append(Rtotal)
                self.Gtotals.append(Gtotal)
                self.Btotals.append(Btotal)
                self.frame_count += 1

                # 일정 프레임 수마다 평균 계산
                if self.frame_count == 5:
                    Ravg = np.mean(self.Rtotals)
                    Gavg = np.mean(self.Gtotals)
                    Bavg = np.mean(self.Btotals)

                    if Ravg > Gavg and Ravg > Bavg:
                        msg.frame_id = '-1'  # CW
                    elif Gavg > Ravg and Gavg > Bavg:
                        msg.frame_id = '0'  # STOP
                    else:
                        msg.frame_id = '+1'  # CCW

                    # 누적 초기화
                    self.Rtotals = []
                    self.Gtotals = []
                    self.Btotals = []
                    self.frame_count = 0

            self.color_pub.publish(msg)

        except CvBridgeError as e:
            self.get_logger().error(f'Failed to convert image: {e}')
        except Exception as e:
            self.get_logger().error(f'Unexpected error: {e}')

if __name__ == '__main__':
    rclpy.init()
    detector = DetermineColor()
    rclpy.spin(detector)
    detector.destroy_node()
    rclpy.shutdown()


