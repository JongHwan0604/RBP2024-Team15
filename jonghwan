import rclpy
import numpy as np
import cv2
from glob import glob

from rclpy.node import Node

from sensor_msgs.msg import Image, CompressedImage
from cv_bridge import CvBridge, CvBridgeError
from std_msgs.msg import Header

class DetermineColor(Node):
    def __init__(self):
        super().__init__('color_detector')
        self.image_sub = self.create_subscription(Image, '/camera/color/image_raw', self.callback, 10)
        self.color_pub = self.create_publisher(Header, '/rotate_cmd', 10)
        self.bridge = CvBridge()

    def callback(self, data):
        try:
            # 이미지 토픽 수신
            image = self.bridge.imgmsg_to_cv2(data, 'bgr8')

            # 이미지의 너비와 높이
            height, width = image.shape[:2]

            # 테두리 정의 (예: 전체 이미지의 5%)
            border_size = 0.05
            border_width = int(width * border_size)
            border_height = int(height * border_size)

            # 테두리 부분 추출
            top_border = image[:border_height, :]
            bottom_border = image[-border_height:, :]
            left_border = image[:, :border_width]
            right_border = image[:, -border_width:]

            # prepare rotate_cmd msg
            msg = Header()
            msg = data.header
            msg.frame_id = '0'  # 기본값: STOP

            # 테두리 색상 분석
            Rtotal, Gtotal, Btotal = 0, 0, 0

            borders = [top_border, bottom_border, left_border, right_border]

            for border in borders:
                hsv_border = cv2.cvtColor(border, cv2.COLOR_BGR2HSV)
                
                # 색상 범위 정의 (여기서는 검은색 제외)
                # 검은색 범위를 넓혀서 테두리에서 검은색이 덜 선택되도록 조정
                lower_black = np.array([0, 0, 0], dtype=np.uint8)
                upper_black = np.array([180, 255, 30], dtype=np.uint8)

                mask_black = cv2.inRange(hsv_border, lower_black, upper_black)
                non_black_border = cv2.bitwise_and(hsv_border, hsv_border, mask=~mask_black)

                # HSV 기준에 따라 색상 계산
                Rtotal += np.sum(((non_black_border[:, :, 0] > 170) | (non_black_border[:, :, 0] < 10)))
                Gtotal += np.sum(((non_black_border[:, :, 0] > 50) & (non_black_border[:, :, 0] < 70)))
                Btotal += np.sum(((non_black_border[:, :, 0] > 110) & (non_black_border[:, :, 0] < 130)))

            # 색상에 따른 회전 방향 결정
            if Rtotal > Gtotal and Rtotal > Btotal:
                msg.frame_id = '-1'  # 시계 방향
            elif Gtotal > Rtotal and Gtotal > Btotal:
                msg.frame_id = '0'   # 정지
            else:
                msg.frame_id = '+1'  # 반시계 방향

            # 색상 상태 발행
            self.color_pub.publish(msg)
        except CvBridgeError as e:
            self.get_logger().error('이미지 변환 실패: %s' % e)

if __name__ == '__main__':
    rclpy.init()
    detector = DetermineColor()
    rclpy.spin(detector)
    detector.destroy_node()
    rclpy.shutdown()
